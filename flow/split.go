// generated by mksplit.sh

package flow

import "go/ast"

func astSplit(x ast.Node) []ast.Node {
	var out []ast.Node
	switch x := x.(type) {
	case *ast.ArrayType:
		if x.Len != nil {
			out = append(out, x.Len)
		}
		if x.Elt != nil {
			out = append(out, x.Elt)
		}

	case *ast.AssignStmt:
		for _, y := range x.Lhs {
			out = append(out, y)
		}
		for _, y := range x.Rhs {
			out = append(out, y)
		}

	case *ast.BadDecl:

	case *ast.BadExpr:

	case *ast.BadStmt:

	case *ast.BasicLit:

	case *ast.BinaryExpr:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Y != nil {
			out = append(out, x.Y)
		}

	case *ast.BlockStmt:
		for _, y := range x.List {
			out = append(out, y)
		}

	case *ast.BranchStmt:
		if x.Label != nil {
			out = append(out, x.Label)
		}

	case *ast.CallExpr:
		if x.Fun != nil {
			out = append(out, x.Fun)
		}
		for _, y := range x.Args {
			out = append(out, y)
		}

	case *ast.CaseClause:
		for _, y := range x.List {
			out = append(out, y)
		}
		for _, y := range x.Body {
			out = append(out, y)
		}

	case *ast.ChanType:
		if x.Value != nil {
			out = append(out, x.Value)
		}

	case *ast.CommClause:
		if x.Comm != nil {
			out = append(out, x.Comm)
		}
		for _, y := range x.Body {
			out = append(out, y)
		}

	case *ast.Comment:

	case *ast.CommentGroup:

	case *ast.CompositeLit:
		if x.Type != nil {
			out = append(out, x.Type)
		}
		for _, y := range x.Elts {
			out = append(out, y)
		}

	case *ast.DeclStmt:

	case *ast.DeferStmt:
		if x.Call != nil {
			out = append(out, x.Call)
		}

	case *ast.Ellipsis:
		if x.Elt != nil {
			out = append(out, x.Elt)
		}

	case *ast.EmptyStmt:

	case *ast.ExprStmt:
		if x.X != nil {
			out = append(out, x.X)
		}

	case *ast.Field:
		for _, y := range x.Names {
			out = append(out, y)
		}
		if x.Type != nil {
			out = append(out, x.Type)
		}

	case *ast.FieldList:

	case *ast.File:
		if x.Name != nil {
			out = append(out, x.Name)
		}
		for _, y := range x.Imports {
			out = append(out, y)
		}
		for _, y := range x.Unresolved {
			out = append(out, y)
		}

	case *ast.ForStmt:
		if x.Init != nil {
			out = append(out, x.Init)
		}
		if x.Cond != nil {
			out = append(out, x.Cond)
		}
		if x.Post != nil {
			out = append(out, x.Post)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.FuncDecl:
		if x.Name != nil {
			out = append(out, x.Name)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.FuncLit:
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.FuncType:

	case *ast.GenDecl:
		for _, y := range x.Specs {
			out = append(out, y)
		}

	case *ast.GoStmt:
		if x.Call != nil {
			out = append(out, x.Call)
		}

	case *ast.Ident:

	case *ast.IfStmt:
		if x.Init != nil {
			out = append(out, x.Init)
		}
		if x.Cond != nil {
			out = append(out, x.Cond)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}
		if x.Else != nil {
			out = append(out, x.Else)
		}

	case *ast.ImportSpec:
		if x.Name != nil {
			out = append(out, x.Name)
		}

	case *ast.IncDecStmt:
		if x.X != nil {
			out = append(out, x.X)
		}

	case *ast.IndexExpr:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Index != nil {
			out = append(out, x.Index)
		}

	case *ast.InterfaceType:

	case *ast.KeyValueExpr:
		if x.Key != nil {
			out = append(out, x.Key)
		}
		if x.Value != nil {
			out = append(out, x.Value)
		}

	case *ast.LabeledStmt:
		if x.Label != nil {
			out = append(out, x.Label)
		}
		if x.Stmt != nil {
			out = append(out, x.Stmt)
		}

	case *ast.MapType:
		if x.Key != nil {
			out = append(out, x.Key)
		}
		if x.Value != nil {
			out = append(out, x.Value)
		}

	case *ast.Package:

	case *ast.ParenExpr:
		if x.X != nil {
			out = append(out, x.X)
		}

	case *ast.RangeStmt:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.ReturnStmt:
		for _, y := range x.Results {
			out = append(out, y)
		}

	case *ast.SelectStmt:
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.SelectorExpr:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Sel != nil {
			out = append(out, x.Sel)
		}

	case *ast.SendStmt:
		if x.Chan != nil {
			out = append(out, x.Chan)
		}
		if x.Value != nil {
			out = append(out, x.Value)
		}

	case *ast.SliceExpr:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Low != nil {
			out = append(out, x.Low)
		}
		if x.High != nil {
			out = append(out, x.High)
		}
		if x.Max != nil {
			out = append(out, x.Max)
		}

	case *ast.StarExpr:
		if x.X != nil {
			out = append(out, x.X)
		}

	case *ast.StructType:

	case *ast.SwitchStmt:
		if x.Init != nil {
			out = append(out, x.Init)
		}
		if x.Tag != nil {
			out = append(out, x.Tag)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.TypeAssertExpr:
		if x.X != nil {
			out = append(out, x.X)
		}
		if x.Type != nil {
			out = append(out, x.Type)
		}

	case *ast.TypeSpec:
		if x.Name != nil {
			out = append(out, x.Name)
		}
		if x.Type != nil {
			out = append(out, x.Type)
		}

	case *ast.TypeSwitchStmt:
		if x.Init != nil {
			out = append(out, x.Init)
		}
		if x.Assign != nil {
			out = append(out, x.Assign)
		}
		if x.Body != nil {
			out = append(out, x.Body)
		}

	case *ast.UnaryExpr:
		if x.X != nil {
			out = append(out, x.X)
		}

	case *ast.ValueSpec:
		for _, y := range x.Names {
			out = append(out, y)
		}
		if x.Type != nil {
			out = append(out, x.Type)
		}
		for _, y := range x.Values {
			out = append(out, y)
		}

	}
	return out
}
